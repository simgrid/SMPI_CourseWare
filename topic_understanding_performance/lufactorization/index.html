<!DOCTYPE html>
<html lang="en-us">


<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Topic &#35;4 Module &middot; SMPI CourseWare
    
  </title>



  <!-- Semantic UI, JQuery, etc. -->
  <link rel="stylesheet" type="text/css" href="/SMPI_CourseWare//semantic/semantic.min.css">
  <link rel="stylesheet" type="text/css" href="/SMPI_CourseWare//public/basics.css">
  <link rel="stylesheet" type="text/css" href="/SMPI_CourseWare//public/syntax.css">

  <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script> -->
  <script src="/SMPI_CourseWare//jquery/jquery.min.js"></script>
  <script src="/SMPI_CourseWare//semantic/components/accordion.js"></script>
  <script src="/SMPI_CourseWare//semantic/components/popup.js"></script>
  <script src="/SMPI_CourseWare//semantic/components/transition.js"></script>
  <script src="/SMPI_CourseWare//semantic/components/tab.js"></script>

  <script language='javascript'>
               $(document).ready(function(){
               $('.ui.accordion').accordion();
               $('.popable')
                   .popup({
                     position: 'right center'
                   })
               ;
                 $('.menu .item').tab();

                 $('.paths.example .menu .item')
                     .tab({
                       context: '.paths.example'
                     })
                 ;

               });
  </script>


</head>



<body>

	

<div class="ui vertical left fixed menu basic  ">
  <br>
  <a href="http://simgrid.org" target="_blank">
  <img width=99 src="/SMPI_CourseWare/public/simgrid_logo.jpg" style="margin-left:5px">
  </a>
  <br>
  <br>




  <a class="ui item " href="/SMPI_CourseWare/">
    <h3 class="ui header">Home</h3>
  </a>


  
  
  
  
  
  <a class="ui popable item fluid " href="/SMPI_CourseWare//000_objectives/"
       data-content="Curricular information" data-variation="inverted">
      <h3 class="ui header fluid">About
      </h3>
  </a>
  
  
  
  
  
  
  
  <a class="ui popable item fluid " href="/SMPI_CourseWare//00_topic/"
       data-content="Getting started with SMPI" data-variation="inverted">
      <h3 class="ui header fluid">Topic &#35;0
      </h3>
  </a>
  
  
  
  
  
  
  
  <a class="ui popable item fluid " href="/SMPI_CourseWare//01_topic/"
       data-content="Basics of distributed memory programming" data-variation="inverted">
      <h3 class="ui header fluid">Topic &#35;1
      </h3>
  </a>
  
  
  
  
  
  
  
  <a class="ui popable item fluid " href="/SMPI_CourseWare//02_topic/"
       data-content="Communication on distributed platforms" data-variation="inverted">
      <h3 class="ui header fluid">Topic &#35;2
      </h3>
  </a>
  
  
  
  
  
  
  
  <a class="ui popable item fluid " href="/SMPI_CourseWare//03_topic/"
       data-content="Rigid distributed memory programs" data-variation="inverted">
      <h3 class="ui header fluid">Topic &#35;3
      </h3>
  </a>
  
  
  
  
  
  
  
  <a class="ui popable item fluid  active" href="/SMPI_CourseWare//04_topic/"
       data-content="Understanding performance" data-variation="inverted">
      <h3 class="ui header fluid">Topic &#35;4
      </h3>
  </a>
  
  
  
  
  
  
  
  <a class="ui popable item fluid " href="/SMPI_CourseWare//05_topic/"
       data-content="Flexible distributed memory programs" data-variation="inverted">
      <h3 class="ui header fluid">Topic &#35;5
      </h3>
  </a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <div class="ui divider" style="margin-top:0em"></div>

</div>



	<div class="contentpage container fluid">
	<div class="page">
  <br>
	
	<h1 class="ui header">Topic &#35;4 Module: LU Factorization</h1>
	
  <div class="ui divider"></div>

	<div class="ui pointing secondary menu">
  <a class="item active" data-tab="intro">Introduction</a>
  <a class="item " data-tab="load_imbalance">Activity #1</a>
  <a class="item " data-tab="roundrobin">Activity #2</a>
  <a class="item " data-tab="scalability">Activity #3</a>
  <a class="item" data-tab="conclusion">Conclusion</a>
</div>

<div class="ui tab segment active" data-tab="intro">
  <div class="ui container raised segment fluid">

  <h3 class="ui header">Overview</h3>

  <p class="ui">
    <b>Objective: </b> To analyze (mostly experimentally) the performance of an implementation
    of the LU factorization algorithm and try to improve it.
  </p>

</div>


<div class="ui container raised segment fluid">

  <h3 class="ui header">Prerequisite </h3>

  <p class="ui">
<b>    This module uses the program developed in the LU Factorization module in Topic #3. You must
    have completed that module to do this one. </b>
  </p>
</div>

<div class="ui container raised segment fluid">

  <h3 class="ui header">Simulation Calibration</h3>

  <p class="ui">

  To make the simulation results consistent regardless of your computer we first calibrate the simulation.
  More specifically, we simulate a parallel platform in which each processor computes 32 times
  faster than one core of the laptop of the author of this module in 2016.  Calibration of simulated
  compute times with SMPI is done by passing a particular floating point value to
  <code>smpirun</code> using the <code>--cfg=smpi/running-power:VALUE</code> command-line option.

  </p>

  <p class="ui">
    A python script called <a href="./calibrate_flops.py"><code>calibrate_flops.py</code></a> is provided, which you should run once
    on your idle computer. This script performs a binary search to find the necessary calibration factor, which is printed
    to the screen and should be passed to the <code>--cfg=smpi/running-power</code> command-line option.
    Of course, if you change computer, you'll have to re-run the script to find a new calibration factor.

  </p>


</div>



<div class="ui container segment raised fluid">
  <h3 class="ui header">Roadmap</h3>
  <p class="ui">This module consists of <b>2 activities, each described in its own tab above, which should be done in
    sequence:</b>
  </p>
  <ul class="ui list">
    <li class="item"><b>Activity #1:</b> Quantify the load imbalance the implementation at large scale.</li>
    <li class="item"><b>Activity #2:</b> Improve the load imbalance.</li>
    <li class="item"><b>Activity #3:</b> Determine the impact of network communication on scalability.</li>
  </ul>
</div>


<div class="ui container segment raised fluid">
  <h3 class="ui header">What to turn in</h3>
  <p class="ui">You should turn in a single archive (or a github repo) with:
  <div class="ui bulleted list">
    <div class="item">All source code</div>
    <div class="item">XML platform files and hostfiles (see details in the activities)</div>
    <div class="item">A Makefile that compiles all executables (and has a 'clean' target!)</div>
  </div>
  </p>
</div>

</div>

<div class="ui tab segment " data-tab="load_imbalance">
  <div class="ui container segment raised">In this activity we investigate whether the original implementation
  achieves good load balance, i.e., do the processes have close to the same amounts of work to do. We wish
  to do this investigation for large matrices, to better observe load balancing behaviors.
   In steps #1 and #2 below we play "simulation tricks" to avoid
  running too memory-intensive / cpu-intensive simulations. In step #3 we re-calibrate the simulation, and
  in step #4 we run experiments to quantify load imbalance.
</div>

<div class="ui top attached tabular menu">
  <a class="item active" data-tab="simulation_tricks_cpu">Step #1: No computation</a>
  <a class="item " data-tab="simulation_tricks_mem">Step #2: Less memory</a>
  <a class="item " data-tab="recalibration">Step #3: Recalibration</a>
  <a class="item " data-tab="load_imbalance_runs">Step #4: Load Imbalance</a>
</div>


<div class="ui bottom attached tab segment active" data-tab="simulation_tricks_cpu">

  <p class="ui">
  Experiments with large matrices are necessary to study scalability, but unfortunately these experiments are cpu-intensive,
  whether on a real platform or in simulation. One advantage of simulation is that one can play tricks to reduce cpu expenses, essentially
  by not performing actual computation.
  This is something researchers often do in simulation and in this module you're doing it too.
</p>

<p class="ui">
  When SMPI encounters a basic block of computation in your program, it executes the block
  and times it to  generate the correct delay in simulation. If this
  code takes 1 hour to run on your machine, then the simulation will then take at least 1
  hour. If you are simulating 100 processes each computing for 1
  hour, then the simulation will take 100 hours! This is because SMPI runs on a single core, running
  MPI processes in round-robin fashion. This sounds bad, but SMPI provides several ways
  to mitigate this problem.  For instance, one can tell the simulator:
  "Execute/time the code only the first time you encounter it".  A more radical
  option is to  tell the simulator: "When you encounter this basic
  block, don't run it at all. Instead, I am telling you how many flops it involves
  and simply compute the delay by dividing this number of flops by the compute speed."
  In both cases, <b>the code no longer computes correct results</b>. But the idea is that for
  deterministic basic blocks, such as the computation and updates in columns in the LU factorization
  implementation, the general performance behavior is preserved,
  and a simple re-calibration will lead to sufficiently accurate simulation results (this has been shown in SMPI research papers and
  by other researchers before SMPI even existed).
</p>

<p class="ui">
In this step we use the second option above, i.e., avoiding computation altogether. Consider the sample
  basic block below:
</p>

<div class="ui container segment raised">

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">*</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

</div>

This loop performs <i>O(N)</i> floating point operations, and in your SMPI code you can replace it by:

<div class="ui container segment raised">
  
<figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="kt">double</span> <span class="n">flops</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">FLOP_CALIBRATION_FACTOR</span> <span class="p">;</span>
  <span class="n">SMPI_SAMPLE_FLOPS</span><span class="p">(</span><span class="n">flops</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// for (i=0; i &lt; N; i++) {
</span>    <span class="c1">//   sum = sum * 3.0 * x * y;
</span>  <span class="p">}</span>
  </code></pre></figure>

</div>
(note that the original code is simply commented-out without the <code>SMPI_SAMPLE_FLOPS</code> macro / basic block, which is
likely a good idea instead of simply deleting it. The <code>FLOP_CALIBRATION_FACTOR</code> constant
is the constant factor hidden in the <i>O(N)</i> asymptotic complexity. In step #3 we use calibration to determine
and appropriate value. Typically, this constant is
very low, so it's a good idea to instead declare:
<div class="ui container segment raised">
  
<figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="kt">double</span> <span class="n">flops</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">FLOP_CALIBRATION_FACTOR</span> <span class="o">/</span> <span class="mf">1.0E+10</span><span class="p">;</span>
  </code></pre></figure>

</div>

<p class="ui">
Modify your program to do the above, for the basic block that computes the k-th column and
  the basic block that updated the lower-right part of the matrix (i.e., the two computational
  for loops in the sequential version of the code, which you have parallelized when completing
  the LU Factorization module in Topic #3). At this point,
since your code doesn't compute anything useful, you can also comment out the part of the code that
initializes the matrices and checks the validity of the results (in fact you really want to comment out the latter
to avoid "invalid results" messages). For now use an arbitrary value for <code>FLOP_CALIBRATION_FACTOR</code> so
that you can compile and debug your program, and pay no attention to the simulated performance.
</p>

</div>


<div class="ui bottom attached tab segment " data-tab="simulation_tricks_mem">

  <p class="ui">
  Besides cpu time, another limiting factor for scalable simulation is memory space. If
  I want to use SMPI to simulate 100 processes that each uses 1GiB of heap space,
  then I need a single machine with 100GiB of RAM! Again, this sounds bad, which is why
  SMPI allows simulated processes to use the same heap allocations!! This leads to
  nonsensical computation since processes overwrite each other's updates in the same
  allocated memory zones. But, for deterministic application such as matrix multiply,
  overall performance behavior is sufficiently preserved to lead to sufficiently accurate
  simulation results (again, see SMPI research papers and those referenced therein).
</p>

<p class="ui">
  The above is straightforward with SMPI:
  <div class="ui bulleted list">
    <div class="ui item">Replace <code>malloc</code> by <code>SMPI_SHARED_MALLOC</code>;</div>
    <div class="ui item">Replace <code>free</code> by <code>SMPI_SHARED_FREE</code>.</div>
  </div>
</p>

<p class="ui">
  Do the above in your program. You now have a program that computes
  nothing useful at all, but still outputs a simulated wallclock time that research shows
  is sufficiently accurate to draw meaningful conclusions for our purpose!
  The point is that this program can be executed faster and for larger matrices.
  We now have an interesting simulation performance trade-off. With a lot of processes, we can scale the memory up.
  For instance, say the memory space needed for the (sequential) matrix multiplication is 100GiB.
  You canâ€™t run the simulation of this computation on your laptop. However, if you simulate a parallel
  execution with 100 processes, the above memory trick makes it so that you only need 1GiB of RAM to run the simulation.
  However, with a lot of processes, the time to simulate the broadcasts with large data sizes is large
  (due to the sheer number of individual point-to-point messages).
  So, some simulations will take too much space, and some simulations will take too much time.
  Nevertheless, our CPU and memory simulation "tricks" significantly widens the range of simulation experiments
  that can be done in practice.
  </p>

</div>


<div class="ui bottom attached tab segment " data-tab="recalibration">

  <p class="ui">
  One problem with our CPU trick is that the simulated wall-clock time will no longer be coherent with our simulation platform, i.e., it
  no longer has anything to do with our --cfg=smpi/running power command-line option since we use the
  <code>SMPI_SAMPLE_FLOPS</code> macro. Instead, we need
  to determine a reasonable value for <code>FLOP_CALIBRATION_FACTOR</code>.
  </p>

<p class="ui">
  Run your original (i.e., without the "simulation tricks") program from the Matrix Multiplication module in Topic #3,
 using
  <a href=""><code>cluster_1600.xml</code></a> and
  <a href=""><code>hostfile_1600.txt</code></a>, for a matrix of size 2000x2000, with <b>p=4 process</b>.
  Then empirically determine a value of <code>FLOP_CALIBRATION_FACTOR</code>
  that leads to the same (or close) simulated elapsed time for your program with the "simulation tricks".
  Doing a binary search on <code>FLOP_CALIBRATION_FACTOR</code>, via a script, is great of course, but you
  can probably just do a quick trial-and-error manual search. Once you've found this value, hard-code it into your
  program, and voila.
</p>

</div>


<div class="ui bottom attached tab segment " data-tab="load_imbalance_runs">

  <p class="ui">
  Now that your simulation is fully calibrated, augment your implementation (in <code>lu.c</code>) so that at the
  end of the execution the program prints out <i>the elapsed time</i> as well as the <i>percentage idle time</i>.
   The idle time corresponds to the column updates phase
  (i.e., at a given iteration some processors will have fewer columns to update than others, and will thus remain idle
  until all processors are ready to move on). As usual, it's a good idea to use <code>MPI_Wtime</code> to measure
  time, and it's ok to add calls to <code>MPI_Barrier</code> to make it easier to measure idle time at
  each process.  The percentage idle time is computed as the sum of all the individual idle times (which you can
  obtain using <code>MPI_Reduce</code>), divided by the product of the number of processes and the elapsed time.
</p>

<p class="ui">
  Run your code using
  <a href="./cluster_1600.xml"><code>cluster_1600.xml</code></a>  and
  <a href="./hostfile_1600.txt"><code>hostfile_1600.txt</code></a>, <b>but</b>
  edit <code>cluster_1600.xml</code> to make the network very fast (zero latency, huge bandwidth). This
  will allow us to take the network out of the equation for now.  Run your code for a
  32000x32000 matrix with p = 1, 4, 8, 16, 32, and 64 processes. On the same graph plot
  the elapsed time and the percentage idle time (using two different left and right vertical axes).

  </p>

<p class="ui">
   In your <code>README</code> file describe what you observe. Is the idle time significant? Does the
   performance scale well as the number of processors increase? Can you explain why that is given
   what the implementation is doing?
</p>


</div>


</div>

<div class="ui tab segment " data-tab="roundrobin">
  <div class="ui container segment raised">In this activity we modify our implementation to improve
  the load balancing, and re-run simulations to see the performance benefit.
</div>

<div class="ui top attached tabular menu">
  <a class="item active" data-tab="cyclic_distribution">Step #1: Cyclic distribution</a>
  <a class="item " data-tab="cyclic_runs">Step #2: Effect on Performance</a>
</div>


<div class="ui bottom attached tab segment active" data-tab="cyclic_distribution">

  <p class="ui">
 The reason for poor load balance in the original implementation is that after some point, a process runs out of
  work to do (because the application proceeds from left to right along the columns of the matrix).  This is an
  artifact of our data distribution. A solution
  is to use a <i>cyclic distribution</i>. More precisely, modify your program, calling it <code>lu_roundrobin.c</code>,
  so that the columns of the matrix are assigned to the processors in Round-Robin fashion
  (rank 0 processes columns 0, p, 2p, 3p,..., rank 1 processes columns 1, p + 1, 2p + 1, 3p + 1,...).
  Of course you must still check that the computed results are correct before moving on to the
  experiments in the next step (i.e., disable the "simulation tricks" for testing correctness).
</p>


</div>


<div class="ui bottom attached tab segment " data-tab="cyclic_runs">

  <p class="ui">
 With the "simulation tricks" from Activity #1 enabled, we can now re-run the same experiments as that
 in Step #4 of Activity #1. That is,
 run your code using
 <a href="./cluster_1600.xml"><code>cluster_1600.xml</code></a>  and
 <a href="./hostfile_1600.txt"><code>hostfile_1600.txt</code></a>, <b>but</b>
 edit <code>cluster_1600.xml</code> to make the network very fast (zero latency, huge bandwidth).
 Run your code for a
 32000x32000 matrix with p = 1, 4, 8, 16, 32, and 64 processes. On the same graph plot
 the elapsed time and the percentage idle time (using two different left and right vertical axes). It would
 be likely useful to plot the results from Activity #1, Step #4 on this same graph as well for easy comparison.
 </p>


<p class="ui">
 In your <code>README</code> file describe what you observe. Does the cyclic distribution reduce
 idle time significantly?
</p>


</div>



</div>

<div class="ui tab segment " data-tab="scalability">
  <div class="ui container segment raised">In this activity we see the effect of communication
  on overall application performance.
</div>

<div class="ui top attached tabular menu">
  <a class="item active" data-tab="network_performance">Step #1: Effect of network performance</a>
</div>


<div class="ui bottom attached tab segment active" data-tab="network_performance">

  <p class="ui">
  Using your last implementation, i.e., the one that achieves good load balancing, run
  your program for a 32000x32000 matrix, p = 1, 4, 8, 16, 32, 64, and 128 processes , using <b>the original</b>
  <a href="cluster_1600.xml"><code>cluster_1600.xml</code></a> platform (with a non-ideal network). Plot the
  parallel efficiency vs. the number of processors.  In your <code>README</code> file describe what you observe.
  What do you conclude in terms of the scalability of your application? Would you say there is work that remains
  to be done? Any ideas?
</p>


</div>




</div>

<div class="ui tab segment" data-tab="conclusion">
  <div class="ui container raised segment fluid">

  <h3 class="ui header">What have we learned?</h3>

  <p class="ui">
    Congratulations for making it this far. You have learned how to measure
    the load imbalance in a
    message passing application, have learned how to implement a cyclic data distribution,
    and have learn how to look at performance results
    and draw conclusions about the scalability of the application, and have
    learned how to use simulation to run large-scale experiments without need for
    a large-scale machine. The performance of the application can be further improve,
    for instance by overlapping communication and computation. In fact, many
    techniques have been developed to improve the performance of this
    particular application.
  </p>


</div>

<div class="ui container raised segment fluid">

  <h3 class="ui header">What was difficult?</h3>

  <p class="ui">
    In your README file write a brief "essay" explaining what you found
    surprising/challenging, and what solutions you used to solve
    your difficulties. Are you happy with your implementations? Do you
    see room for improvement?
  </p>


</div>

<div class="ui container raised segment fluid">

<div class="ui horizontal divider">
  The End
</div>

</div>
</div>



  <br>

</div>
	</div>



</body>
</html>
