<!DOCTYPE html>
<html lang="en-us">


<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Topic &#35;1 Module &middot; SMPI CourseWare
    
  </title>



  <!-- Semantic UI, JQuery, etc. -->
  <link rel="stylesheet" type="text/css" href="/SMPI_CourseWare//semantic/semantic.min.css">
  <link rel="stylesheet" type="text/css" href="/SMPI_CourseWare//public/basics.css">
  <link rel="stylesheet" type="text/css" href="/SMPI_CourseWare//public/syntax.css">

  <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script> -->
  <script src="/SMPI_CourseWare//jquery/jquery.min.js"></script>
  <script src="/SMPI_CourseWare//semantic/components/accordion.js"></script>
  <script src="/SMPI_CourseWare//semantic/components/popup.js"></script>
  <script src="/SMPI_CourseWare//semantic/components/transition.js"></script>
  <script src="/SMPI_CourseWare//semantic/components/tab.js"></script>

  <script language='javascript'>
               $(document).ready(function(){
               $('.ui.accordion').accordion();
               $('.popable')
                   .popup({
                     position: 'right center'
                   })
               ;
                 $('.menu .item').tab();

                 $('.paths.example .menu .item')
                     .tab({
                       context: '.paths.example'
                     })
                 ;

               });
  </script>


</head>



<body>

	

<div class="ui vertical left fixed menu basic  ">
  <br>
  <a href="http://simgrid.org" target="_blank">
  <img width=99 src="/SMPI_CourseWare/public/simgrid_logo.jpg" style="margin-left:5px">
  </a>
  <br>
  <br>




  <a class="ui item " href="/SMPI_CourseWare/">
    <h3 class="ui header">Home</h3>
  </a>


  
  
  
  
  
  <a class="ui popable item fluid " href="/SMPI_CourseWare//000_objectives/"
       data-content="Curricular information" data-variation="inverted">
      <h3 class="ui header fluid">About
      </h3>
  </a>
  
  
  
  
  
  
  
  <a class="ui popable item fluid " href="/SMPI_CourseWare//00_topic/"
       data-content="Getting started with SMPI" data-variation="inverted">
      <h3 class="ui header fluid">Topic &#35;0
      </h3>
  </a>
  
  
  
  
  
  
  
  <a class="ui popable item fluid  active" href="/SMPI_CourseWare//01_topic/"
       data-content="Basics of distributed memory programming" data-variation="inverted">
      <h3 class="ui header fluid">Topic &#35;1
      </h3>
  </a>
  
  
  
  
  
  
  
  <a class="ui popable item fluid " href="/SMPI_CourseWare//02_topic/"
       data-content="Communication on distributed platforms" data-variation="inverted">
      <h3 class="ui header fluid">Topic &#35;2
      </h3>
  </a>
  
  
  
  
  
  
  
  <a class="ui popable item fluid " href="/SMPI_CourseWare//03_topic/"
       data-content="Rigid distributed memory programs" data-variation="inverted">
      <h3 class="ui header fluid">Topic &#35;3
      </h3>
  </a>
  
  
  
  
  
  
  
  <a class="ui popable item fluid " href="/SMPI_CourseWare//04_topic/"
       data-content="Understanding performance" data-variation="inverted">
      <h3 class="ui header fluid">Topic &#35;4
      </h3>
  </a>
  
  
  
  
  
  
  
  <a class="ui popable item fluid " href="/SMPI_CourseWare//05_topic/"
       data-content="Flexible distributed memory programs" data-variation="inverted">
      <h3 class="ui header fluid">Topic &#35;5
      </h3>
  </a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <div class="ui divider" style="margin-top:0em"></div>

</div>



	<div class="contentpage container fluid">
	<div class="page">
  <br>
	
	<h1 class="ui header">Topic &#35;1 Module: Computing a Julia Set</h1>
	
  <div class="ui divider"></div>

	<div class="ui pointing secondary menu">
  <a class="item active" data-tab="first">Introduction</a>
  <a class="item " data-tab="second">Activity #1</a>
  <a class="item" data-tab="third">Activity #2</a>
  <a class="item" data-tab="fourth">Activity #3</a>
  <a class="item" data-tab="fifth">Conclusion</a>
</div>

<div class="ui tab segment active" data-tab="first">
  <div class="ui container raised segment fluid">

  <h3 class="ui header">Overview</h3>

  <p class="ui">
    <b>Objective: </b> To implement several versions of a "toy" parallel application that
    computes the Julia set displayed below and saves it as a bitmap file:
  </p>

  <p style="text-align:center;" class="ui">
    <img align="center" src="./julia_small.jpg" />
  </p>

  



<div class="ui accordion">
  <div class=" title">
    <i class="dropdown icon"></i>
    What is a Julia set?
  </div>
  <div class=" content">
    <div class="ui container message ">
      <p class="ui">A Julia set is a fractal, i.e., an object that is self-similar across scales (you "zoom in"
        and you keep seeing similar structures/features). It is a generalization
        of the famous Mandelbrot set<sup><a href="https://en.wikipedia.org/wiki/Mandelbrot_set">[Wikipedia]</a></sup>,
        which adorns many T-shirts (search for "Mandelbrot zoom" for psychedelic videos). </p>

      <p class="ui">The particular Julia set
        that we compute here is defined as follows. Given z a point in the 2-D complex plane, we compute the
        series defined as:
      <ul class="ui list">
        <li class="item">z<sub>0</sub> = z</li>
        <li class="item">z<sub>n+1</sub> = z<sub>n</sub><sup>2</sup> + c</li>
      </ul>
      where c = -0.79 + i * 0.15. Different
      values of c lead to different images, and we know many values that produce "pretty" images.
      </p>
      <p class="ui">
        The color of a pixel corresponding to point z is determined based on the number of iterations
        before the modulus of z<sub>n</sub> is above 2 (or until a maximum number of iterations
        is reached).
      </p>
      <p class="ui">
        Not to worry, code is provided for you for the above. However, feel free to tweak it to create different
        images and to find out more about Julia sets<sup><a href="https://en.wikipedia.org/wiki/Julia_set">[Wikipedia]</a></sup>.
      </p>
    </div>
  </div>
</div>


</div>

<div class="ui container segment raised fluid">
  <h3 class="ui header">Roadmap</h3>
  <p class="ui">This module consists of <b>3 activities, each described in its own tab above, which should be done in
    sequence:</b>
  </p>
  <ul class="ui list">
    <li class="item"><b>Activity #1:</b> Realize a sequential implementation of a program that computes the Julia set
      and
      outputs it to a bmp file.
    </li>
    <li class="item"><b>Activity #2:</b> Realize a parallel implementation the program with MPI, using a 1-D data
      distribution.
    </li>
    <li class="item"><b>Activity #3:</b> Realize a parallel implementation the program with MPI, using a 2-D data
      distribution.
    </li>
  </ul>

</div>


<div class="ui container segment raised fluid">
  <h3 class="ui header">What to turn in</h3>
  <p class="ui">You should turn in a single archive (or a github repo) with:
  <div class="ui bulleted list">
    <div class="item">All source code</div>
    <div class="item">XML platform files  and host files (see details in the activities)</div>
    <div class="item">A Makefile that compiles all executables (and has a 'clean' target!)</div>
    <div class="item">A README file with answers to the questions asked in the activities</div>
  </div>
  </p>
</div>
</div>

<div class="ui tab segment " data-tab="second">
  In this activity we develop a simple sequential (i.e., non-parallel) program that computes a
Julia set and saves it to a bitmap file. We break it down into the two steps below:
<br />

<div class="ui top attached tabular menu">
  <a class="item active" data-tab="seq_compute_julia">Step #1: Computing the Julia set</a>
  <a class="item" data-tab="seq_save_to_file">Step #2: Saving to a file</a>
</div>

<div class="ui bottom attached tab segment active" data-tab="seq_compute_julia">

  Implement a C (or C++) program called <code>sequential_julia</code> (source file  <code>sequential_julia.c</code>) that:

<div class="ui list bulleted">
  <div class="item">Takes a single command-line argument, n, an <code>integer</code> that's strictly positive.</div>
  <div class="item">Allocates an 1-D <code>unsigned char</code> array of  n*(2*n)*3 elements. This array is used to store
    the pixels of an image with height (in pixels) of n width (in pixels) of 2n, where each pixel is encoded using 3 bytes (RGB
    values).
  </div>
  <div class="item">Fills this array with pixel values corresponding to the Julia set.</div>
</div>

<p class="ui">
  To make the above easier you are provided with one helper C function, <code>compute_julia_pixel()</code>, to which
  you pass the (x,y) coordinates of a pixed, the (width, height) dimensions of the image, a "tint" float (pass 1.0
  for now), and a pointer to 3 contiguous bytes (<code>unsigned char *</code>). These bytes are set to appropriate
  RGB values (Red Green Blue) for displaying the Julia set.
  <a target="_blank" href="/SMPI_CourseWare/topic_basics_of_distributed_memory_programming/julia_set/compute_julia_pixel.c">[Download
    source of compute_julia_pixel()]</a>
</p>

<div class="ui accordion fluid">
  <div class=" title">
    <i class="dropdown icon"></i>
    See the source of compute_julia_pixel()...
  </div>
  <div class=" content">
    <div class="ui raised container segment ">

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/*
 * compute_julia_pixel(): compute RBG values of a pixel in a
 *                        particular Julia set image.
 *
 *  In:
 *      (x,y):            pixel coordinates
 *      (width, height):  image dimensions
 *      tint_bias:        a float to "tweak" the tint (1.0 is "no tint")
 *  Out:
 *      rgb: an already-allocated 3-byte array into which R, G, and B
 *           values are written.
 *
 *  Return:
 *      0 in success, -1 on failure
 *
 */</span>

<span class="kt">int</span> <span class="nf">compute_julia_pixel</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tint_bias</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rgb</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// Check coordinates</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">width</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">height</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"Invalid (%d,%d) pixel coordinates in a %d x %d image</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// "Zoom in" to a pleasing view of the Julia set</span>
  <span class="kt">float</span> <span class="n">X_MIN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">6</span><span class="p">,</span> <span class="n">X_MAX</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">6</span><span class="p">,</span> <span class="n">Y_MIN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">9</span><span class="p">,</span> <span class="n">Y_MAX</span> <span class="o">=</span> <span class="o">+</span><span class="mi">0</span><span class="p">.</span><span class="mi">9</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">float_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">Y_MAX</span> <span class="o">-</span> <span class="n">Y_MIN</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">y</span> <span class="o">/</span> <span class="n">height</span> <span class="o">+</span> <span class="n">Y_MIN</span> <span class="p">;</span>
  <span class="kt">float</span> <span class="n">float_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_MAX</span> <span class="o">-</span> <span class="n">X_MIN</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">x</span> <span class="o">/</span> <span class="n">width</span>  <span class="o">+</span> <span class="n">X_MIN</span> <span class="p">;</span>

  <span class="c1">// Point that defines the Julia set</span>
  <span class="kt">float</span> <span class="n">julia_real</span> <span class="o">=</span> <span class="o">-</span><span class="p">.</span><span class="mi">79</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">julia_img</span> <span class="o">=</span> <span class="p">.</span><span class="mi">15</span><span class="p">;</span>

  <span class="c1">// Maximum number of iteration</span>
  <span class="kt">int</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>

  <span class="c1">// Compute the complex series convergence</span>
  <span class="kt">float</span> <span class="n">real</span><span class="o">=</span><span class="n">float_y</span><span class="p">,</span> <span class="n">img</span><span class="o">=</span><span class="n">float_x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">num_iter</span> <span class="o">=</span> <span class="n">max_iter</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">((</span> <span class="n">img</span> <span class="o">*</span> <span class="n">img</span> <span class="o">+</span> <span class="n">real</span> <span class="o">*</span> <span class="n">real</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">num_iter</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">))</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">xtemp</span> <span class="o">=</span> <span class="n">img</span> <span class="o">*</span> <span class="n">img</span> <span class="o">-</span> <span class="n">real</span> <span class="o">*</span> <span class="n">real</span> <span class="o">+</span> <span class="n">julia_real</span><span class="p">;</span>
    <span class="n">real</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">img</span> <span class="o">*</span> <span class="n">real</span> <span class="o">+</span> <span class="n">julia_img</span><span class="p">;</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">xtemp</span><span class="p">;</span>
    <span class="n">num_iter</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Paint pixel based on how many iterations were used, using some funky colors</span>
  <span class="kt">float</span> <span class="n">color_bias</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">num_iter</span> <span class="o">/</span> <span class="n">max_iter</span><span class="p">;</span>
  <span class="n">rgb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_iter</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">200</span> <span class="o">:</span> <span class="o">-</span> <span class="mi">500</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">tint_bias</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span>  <span class="n">pow</span><span class="p">(</span><span class="n">color_bias</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">6</span><span class="p">));</span>
  <span class="n">rgb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_iter</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">100</span> <span class="o">:</span> <span class="o">-</span><span class="mi">255</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span>  <span class="n">pow</span><span class="p">(</span><span class="n">color_bias</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="p">));</span>
  <span class="n">rgb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_iter</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">100</span> <span class="o">:</span> <span class="mi">255</span> <span class="o">-</span> <span class="mi">255</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">tint_bias</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">color_bias</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

    </div>
  </div>
</div>

<br />

<p class="ui">
  The program must store the pixels of the 2-D image into the <b>1-D array using a <i>row-major scheme</i></b>.
</p>


<div class="ui accordion fluid">
  <div class=" title">
    <i class="dropdown icon"></i>
    See more details about this "row-major" business...
  </div>

  <div class="content">
    <div class="ui container raised segment">
      <h4 class="ui header">Storing 2-D data is a row-major 1-D array</h4>
      <p class="ui">
        You may find the use of a 1-D array to store the pixels surprising, since after all the image is 2-D. However, it is
        common to use 1-D arrays, especially when they are dynamically allocated. One option would be to allocate an array
        of pointers to
        1-D arrays, where each 1-D array represents a pixel row. This would make it possible to access elements with the convenient syntax <code>Array[i][j]</code>.
        But this is typically a bad idea as it reduces locality (i.e., the efficient use of the cache), which in turns harms
        performance.
      </p>
      <p>Therefore, we instead store 2-D data into a 1-D array of contiguous elements. The "row-major" scheme consists in storing rows in sequence. In other
        terms, if the width of the image is <code>N</code>, then pixel (i,j) is stored as <code>Array[i * N + j]</code>. This is actually
        the scheme used by the C language to store 2-D arrays.
      </p>
    </div>
  </div>
</div>
<br />


Now that the program computes the Julia set pixels as a 1-D array of 3-byte elements, it would be nice to see them (if only to check
that they're set correctly). So let's move on to Step #2...





</div>



<div class="ui bottom attached tab segment" data-tab="seq_save_to_file">

  <p class="ui">
Augment your program so that it saves the image to a file called <code>julia.bmp</code>, which stores
the image in the bmp format.  A bmp file consists of two parts:
  <div class="ui list bulleted">
  <div class="ui item"> A header </div>
  <div class="ui item"> The 3-byte pixels of the image, in a row-major fashion</div>
</div>

  </p>

<p class="ui">
  To make the above easier you are first provided with a helper C function, <code>write_bmp_header()</code>, which
  writes to a file the 40-byte header required for a bmp file.
  <a target="_blank" href="/SMPI_CourseWare/topic_basics_of_distributed_memory_programming/julia_set/write_bmp_header.c">[Download
    source of write_bmp_header()]</a>
</p>

<div class="ui accordion fluid">
  <div class=" title">
    <i class="dropdown icon"></i>
    See the source of write_bmp_header()...
  </div>
  <div class=" content">
    <div class="ui raised container segment ">

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* write_bmp_header():
 *
 *   In:
 *      f: A file open for writing ('w') 
 *      (width, height): image dimensions
 *   
 *   Return:
 *      0 on success, -1 on failure
 *
 */</span>

<span class="kt">int</span> <span class="nf">write_bmp_header</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">row_size_in_bytes</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> 
	  <span class="p">((</span><span class="n">width</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">));</span>

  <span class="c1">// Define all fields in the bmp header</span>
  <span class="kt">char</span> <span class="n">id</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"BM"</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filesize</span> <span class="o">=</span> <span class="mi">54</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">row_size_in_bytes</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
  <span class="kt">short</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">54</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">planes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">compression</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">image_size</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">x_res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y_res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ncolors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">importantcolors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Write the bytes to the file, keeping track of the</span>
  <span class="c1">// number of written "objects"</span>
  <span class="kt">size_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filesize</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="n">reserved</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">width</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">height</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">planes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bits</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compression</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x_res</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y_res</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncolors</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">+=</span> <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">importantcolors</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

  <span class="c1">// Success means that we wrote 17 "objects" successfully</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">17</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

    </div>
  </div>
</div>


<p class="ui">
  Second, here is a code fragment that shows how to write the pixels in a 1-D pixed array  to 
  a bpm file (opened as file <code>output_file</code>) after the header has been written:
</p>


<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Writing the pixels after the header</span>
<span class="k">for</span> <span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pixels</span><span class="p">[</span><span class="n">y</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">output_file</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// padding in case of an even number of pixels per row</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">padding</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
  <span class="n">fwrite</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">),</span> <span class="p">((</span><span class="n">width</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">),</span> <span class="n">output_file</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>


<p class="ui">
  Given the above, it should be straightforward to augment your program so that it
  produces a bmp file of the Julia set.  Once this is done, you are ready
  to go on to Activity #2, in which we make the program parallel!
</p>



</div>
</div>

<div class="ui tab segment" data-tab="third">
  In this activity we develop a parallel implementation of the program using
a simple <b>1-D data distribution</b>. We break it down into the three steps below:
<br />

<div class="ui top attached tabular menu">
  <a class="item active" data-tab="1D_data_distribution">Step #1: Data distribution</a>
  <a class="item" data-tab="1D_compute_julia">Step #2: Computing</a>
  <a class="item" data-tab="1D_save_to_file">Step #3: Saving to file</a>
</div>

<div class="ui bottom attached tab segment active" data-tab="1D_data_distribution">

  <p class="ui">
  The first step when designing a distributed-memory program is to pick a particular
  "data distribution", i.e., a way in which the data (input and or output) is
  split across the participating processes. In our Julia set program, the only data
  is the output image, and we opt for a simple and popular data-distribution scheme:
  <b>a 1-D data-distribution</b>. Simply put, we logically split our image into slabs
  and each process computes one slab.
</p>

<p class="ui">Because in the previous activity we used
  a <i>row-major</i> storing scheme for our image, it makes sense to pick horizontal
  slabs.  Our image has n rows of pixels (recall that n is the integer
  command-line argument).  Let us first compute the data distribution,
  without computing the Julia set at all. The idea is that, based on its rank, each
  process must figure out which rows it will compute.
</p>


<p class="ui">
  Implement a C (or C++) MPI program called <code>1D_parallel_julia</code> (source file  <code>1D_parallel_julia.c</code>)
  that:
</p>

<div class="ui list bulleted">
  <div class="item">Takes a single command-line argument, n, an integer that's strictly positive.</div>
  <div class="item">Has each process print out its rank (out of how many processes in total), and
          which rows of the image (as a range) it should compute (but actually do nothing for now). See the sample
           executions below to see what kind of output is expected.
  <div class="ui list bulleted">
  <div class="item">The intended data distribution should be in as many "slabs" as there are processes, where
    each process is in charge of a set of contiguous rows.</div>
  </div>
</div>

<p class="ui">
  <b>For simplicity, you can assume that the number of processes divides n, so that all processes have the same exact number of rows to compute.</b>
  <i>For more of a challenge,</i> you may want to make sure that the distribution is as balanced as possible (at most
  a difference of one row between two processes). This can be done using discrete math so that everything is computed by a single formula,
  but can also be done programmatically with a loop (i.e., "counting by hand").
</p>

<p class="ui">
  Run your program on this simple simulated 1024-node cluster
  (download <a href="simple_cluster.xml">simple_cluster.xml</a> and
  <a href="simple_cluster_hostfile.txt">simple_cluster_hostfile.txt</a>).
</p>

<br />
<div class="ui divider"></div>


<p class="ui">
  Below are a few sample executions of the program <b>(this version of the program does not assume that the number of processes divides n, and enforces a "as balanced as possible" data distribution)</b>:
</p>

<div class="ui accordion  fluid">

  <div class="title">
    <i class="dropdown icon"></i>
    See a sample execution with 5 processes for n=1000 ...
  </div>

  <div class="  styled content">

    <div class="ui container raised segment">
      <h5 class="ui">As expected, each process process should process 200 rows:</h5>

<figure class="highlight"><pre><code class="language-text" data-lang="text">% smpicc -O3 1D_parallel_julia.c -o 1D_parallel_julia
% smpirun -np 5 -hostfile ./simple_cluster_hostfile.txt -platform ./simple_cluster.xml ./1D_parallel_julia 1000
[Process 0 out of 5]: I should compute pixel rows 0 to 199, for a total of 200 rows
[Process 1 out of 5]: I should compute pixel rows 200 to 399, for a total of 200 rows
[Process 2 out of 5]: I should compute pixel rows 400 to 599, for a total of 200 rows
[Process 3 out of 5]: I should compute pixel rows 600 to 799, for a total of 200 rows
[Process 4 out of 5]: I should compute pixel rows 800 to 999, for a total of 200 rows</code></pre></figure>

    </div>
  </div>

  <div class=" title">
    <i class="dropdown icon"></i>
    See a sample execution with 16 processes for n=100 ...
  </div>

  <div class=" content">
    <div class="ui container segment raised">
      <h5 class="ui">Note that the distribution is balanced, meaning that the number of rows
        differs by at most 1 across processors. This is not the only possible balanced data distribution (e.g.,
      process 0 could compute only 6 rows, while process 15 could compute 7 rows).</h5>

<figure class="highlight"><pre><code class="language-text" data-lang="text">% smpicc -O3 1D_parallel_julia.c -o 1D_parallel_julia
% smpirun -np 16 -hostfile ./simple_cluster_hostfile.txt -platform ./simple_cluster.xml ./1D_parallel_julia 100
[Process 0 out of 16]: I should compute pixel rows 0 to 6, for a total of 7 rows
[Process 1 out of 16]: I should compute pixel rows 7 to 13, for a total of 7 rows
[Process 2 out of 16]: I should compute pixel rows 14 to 20, for a total of 7 rows
[Process 3 out of 16]: I should compute pixel rows 21 to 27, for a total of 7 rows
[Process 4 out of 16]: I should compute pixel rows 28 to 33, for a total of 6 rows
[Process 5 out of 16]: I should compute pixel rows 34 to 39, for a total of 6 rows
[Process 6 out of 16]: I should compute pixel rows 40 to 45, for a total of 6 rows
[Process 7 out of 16]: I should compute pixel rows 46 to 51, for a total of 6 rows
[Process 8 out of 16]: I should compute pixel rows 52 to 57, for a total of 6 rows
[Process 9 out of 16]: I should compute pixel rows 58 to 63, for a total of 6 rows
[Process 10 out of 16]: I should compute pixel rows 64 to 69, for a total of 6 rows
[Process 11 out of 16]: I should compute pixel rows 70 to 75, for a total of 6 rows
[Process 12 out of 16]: I should compute pixel rows 76 to 81, for a total of 6 rows
[Process 13 out of 16]: I should compute pixel rows 82 to 87, for a total of 6 rows
[Process 14 out of 16]: I should compute pixel rows 88 to 93, for a total of 6 rows
[Process 15 out of 16]: I should compute pixel rows 94 to 99, for a total of 6 rows</code></pre></figure>

    </div>
  </div>


  <div class=" title">
    <i class="dropdown icon"></i>
    See a sample execution with 16 processes for n=12 ...
  </div>

  <div class=" content">
    <div class="ui container segment raised">
      <h5 class="ui">Note that because n is small, some processes have nothing to do. (We don't care what
      these processes print as their range of rows).</h5>

<figure class="highlight"><pre><code class="language-text" data-lang="text">% smpicc -O3 1D_parallel_julia.c -o 1D_parallel_julia
% smpirun -np 16 -hostfile ./simple_cluster_hostfile.txt -platform ./simple_cluster.xml ./1D_parallel_julia 100
[Process 1 out of 16]: I should compute pixel rows 1 to 1, for a total of 1 rows
[Process 2 out of 16]: I should compute pixel rows 2 to 2, for a total of 1 rows
[Process 3 out of 16]: I should compute pixel rows 3 to 3, for a total of 1 rows
[Process 4 out of 16]: I should compute pixel rows 4 to 4, for a total of 1 rows
[Process 5 out of 16]: I should compute pixel rows 5 to 5, for a total of 1 rows
[Process 6 out of 16]: I should compute pixel rows 6 to 6, for a total of 1 rows
[Process 7 out of 16]: I should compute pixel rows 7 to 7, for a total of 1 rows
[Process 8 out of 16]: I should compute pixel rows 8 to 8, for a total of 1 rows
[Process 9 out of 16]: I should compute pixel rows 9 to 9, for a total of 1 rows
[Process 10 out of 16]: I should compute pixel rows 10 to 10, for a total of 1 rows
[Process 11 out of 16]: I should compute pixel rows 11 to 11, for a total of 1 rows
[Process 12 out of 16]: I should compute pixel rows 12 to 11, for a total of 0 rows
[Process 13 out of 16]: I should compute pixel rows 12 to 11, for a total of 0 rows
[Process 14 out of 16]: I should compute pixel rows 12 to 11, for a total of 0 rows
[Process 15 out of 16]: I should compute pixel rows 12 to 11, for a total of 0 rows</code></pre></figure>

    </div>
  </div>
  </div>
  </div>

</div>



<div class="ui bottom attached tab segment" data-tab="1D_compute_julia">

  <p class="ui">
  Augment your program so that each process allocates space to store the pixels it needs to compute, and
  then computes them. <b>A process must only allocate space for the pixels it needs to compute</b>.  In practice,
  each process runs on a different hosts, and one wishes to compute a large image that does not fit in the
  memory of a single host (which is one of the main motivations for going the "distributed-memory computing" route).
</p>

<p class="ui">
  The main difficulty here is keeping local vs. global indexing straight. That is, although as programmers
  we think of the image as an array of, say, N pixels, no N-pixel array is ever allocated in the program (only
  smaller arrays allocated by each process).
</p>

<div class="ui accordion fluid">

  <div class="title">
    <i class="dropdown icon"></i>
    See more details about this local/global indexing thing ...
  </div>

  <div class="content">

    <div class="ui container message ">

<p class="ui">One of the difficulties of distributed-memory computing is just that... well... memory is distributed.
      Say my sequential non-distributed-memory program processes 2000 items. I can simply store them
      in a 2000-item array.  Say now that I need to use distributed-memory computing (perhaps 2000 items don't
      fit in the memory of a single host, perhaps I just want to compute faster). I now use 20 hosts instead
      of 1, and on each host one process runs and allocates memory for 100 items.  So, at each process I allocate
      a 100-item array. So far, so good.</p>

      <p class="ui"> The problem is that when my sequential program says "process item #i", for some i between 0
        and 1999, I need to figure out two things:
      </p>

      <div class="ui list bulleted">
      <div class="ui item">Which process holds item #i?</div>
      <div class="ui item">In that process' item array, at which index is item #i stored?</div>
      </div>

      <p class="ui">
      The answer to the above depends on the data distribution!  Say that process 0 (i.e., process with
        rank 0) holds items 0 to 99 (global indices), process 1 holds items 100 to 199 (global indices), etc.
        So, for a given i between 0 and 1999, with this data distribution, I have:
      </p>
      <div class="ui list bulleted">
        <div class="ui item">Item #i is held by process with rank i/100</div>
        <div class="ui item">At that process, item #i is store at index i%100 of the item array</div>
      </div>

      <p class="ui">i%100 ("i modulo 100") above is called the <i>local index</i> (i.e., where the element is stored
      in the array declared locally in the process), as opposed to i which is the <i>global index</i>.</p>

      <p>The more complicated the distribution, the more intricate the global-to-local or local-to-global
      conversion. 1-D data distributions, like the one above, are the simplest. In the next activity we'll deal with a 2-D
      data distribution.</p>

    </div>
  </div>
</div>



</div>



<div class="ui bottom attached tab segment" data-tab="1D_save_to_file">

  <p class="ui">
  Augment your program so that the Julia set is saved to a bmp file. This requires some coordination between the
  processes:
<div class="ui list bulleted">
  <div class="ui item">Only one process must create the file and write the header</div>
  <div class="ui item">Processes need to write pixel rows in sequence, one after the other</div>
  <div class="ui item">It's probably a good idea to have the file opened in only a single process at a time</div>
</div>
</p>

<p class="ui">
  First you must pick one process to create the file and write the header to it
  (it is typical to pick process of rank 0).  Second, each process, after its done computing
  its pixels, waits for a "go ahead!" message from its predecessor, writes to the file, and then sends a "go ahead!"
  message to its successor.  The exceptions are the process with rank 0, which does not need to wait for
  a message, and the last process, which does not need to send a message. It doesn't really matter
  what these messages contain (e.g., they can be a single byte, or even zero-byte messages),
  as the whole purpose is to just have processes wait for their predecessors, not really receive
  meaningful data from them.
</p>

<p class="ui">
  <b>Warning:</b> Make sure that your processes compute in parallel. That is, all processes compute together, and then
  they take turn writing what they have computed to the file.
</p>


<p class="ui">
  Experiment with different numbers of processors and different values of n, and check that your bmp file
  is correct (valid, and contains the correct image).
</p>





<div class="ui accordion fluid">

  <div class="title">
    <i class="dropdown icon"></i>
    What are logical topologies???
  </div>

  <div class="content">
    <p class="ui message">
      Although the above scheme is pretty simple, what we are really doing is creating a <i>logical topology</i>. That is,
      based on process rank, we impose structure on our set of processes. In this case, a "linear chain" in which process #i communicates
      with process #i+1. Probably the simplest structure. We will see examples of more complex logical topologies.
      Different applications lend themselves naturally to different logical topologies (rings, grids, trees, etc.).
      One interesting question, which is outside
      the score of this topic, is how well the logical topology matches the physical topology of the actual
      parallel platform in use (a good match typically boosts performance).  Ideally, one can define a logical topology
      that makes writing the application easy, and that is also well-matched to the physical platform.
    </p>
  </div>
</div>




</div>
</div>

<div class="ui tab segment" data-tab="fourth">
  In this activity we develop a parallel implementation of the program using
a  "2-D data distribution". Just like for the previous activity,
we break it down into the three steps below:
<br />

<div class="ui top attached tabular menu">
  <a class="item active" data-tab="2D_data_distribution">Step #1: Data distribution</a>
  <a class="item" data-tab="2D_compute_julia">Step #2: Computing</a>
  <a class="item" data-tab="2D_save_to_file">Step #3: Saving to file</a>
</div>

<div class="ui bottom attached tab segment active" data-tab="2D_data_distribution">

  <p class="ui" xmlns="http://www.w3.org/1999/html">
  We now implement our parallel Julia set application using a <i>2-D data distribution</i>. This means
  that each process now is in charge of a <b>tile</b> of the image in a logical checkerboard pattern. To
  make things simple we assume two things:

<div class="ui list bulleted">
  <div class="ui item"><b>the total number of processes used is always a perfect square, p<sup>2</sup></b></div>
  <div class="ui item"><b>n, the image height, is perfectly divisible by p</b></div>
</div>

</p>

<p class="ui">
  These assumptions will not change the spirit of the program, but simplify its implementation
  significantly. This is because each process is responsible for a tile of the image
  with height n/p and width 2n/p. This is the amount of memory each process should allocate.
</p>

<p class="ui">
  This 2-D data distribution complicates the global vs. local indexing issue that was
  discussed in Activity #2. The first thing to do is to figure out which process is responsible
  for which tile. A common approach is to use a row-major view of the processes. In other words,
  we think of a logical topology in which the processes are organized in a square grid (because
  our number of processes is a perfect square).  By default, MPI gives us only a linear (i.e., 1-D) rank.
  We "transform" this rank into a 2-D rank where each process has a "row" and a "column", using a row-major
  scheme. This can be done with a little bit of discrete math (alternately, MPI provides
  a <code>MPI_Cart_coords</code> function that does this for you).  Based on its 2-D coordinates, a process
  now knows which tile is is responsible for.
</p>

<div class="ui accordion fluid">

  <div class="title">
    <i class="dropdown icon"></i>
    See an example...
  </div>

  <div class="content">
    <div class="ui message">

      <p class="ui">
        Let's say our image has height 300 and width 600, and that we are using 9 processes. Each process
        then is responsible for a 100x200 tile. Let's see this on a "picture":
      </p>

      <div class="grid ui">

        <div class="column two wide"></div>
        <div class="column twelve wide">
          <table class="ui table definition celled">
            <thead>
            <tr>
              <th> global index ranges</th>
              <th> cols [0-199]</th>
              <th> cols [200-399]</th>
              <th> cols [400-599]</th>
            </tr>
            </thead>

            <tbody>
            <tr>
              <td> rows [0-99]</td>
              <td> rank: 0<br />2-D rank: (0,0)<br /></td>
              <td> rank: 1<br />2-D rank: (0,1)<br /></td>
              <td> rank: 2<br />2-D rank: (0,2)<br /></td>
            </tr>
            <tr>
              <td> rows [100-199]</td>
              <td> rank: 3<br />2-D rank: (1,0)<br /></td>
              <td> rank: 4<br />2-D rank: (1,1)<br /></td>
              <td> rank: 5<br />2-D rank: (1,2)<br /></td>
            </tr>
            <tr>
              <td> rows [200-299]</td>
              <td> Rank: 6<br />2-D rank: (2,0)<br /></td>
              <td> Rank: 7<br />2-D rank: (2,1)<br /></td>
              <td> Rank: 8<br />2-D rank: (2,2)<br /></td>
            </tr>

            </tbody>
          </table>
        </div>

        <div class="column two wide"></div>
      </div>
      <br />

      <p class="ui">
        Every white cell above represents a tile. The (global) row
        and column index ranges for the pixels in the tile are shown
        in the first row/column. In each tile is shown the rank of the process
        that owns it, and the 2-D rank of this process (computed based
        in the process rank and  p). For instance, process of rank 5
        has 2-D rank (1,2), meaning that it is in the 2nd row and the 3rd
        column of the logical 3x3 process grid. As such, it is responsible
        for image pixels between rows 100 and 199 and between columns 400 and 599. In
        "array slice notation, this would be [100:199, 400:599].
      </p>

    </div>

  </div>
</div>

<p class="ui">
  Implement a program called <code>2D_parallel_julia</code> (source <code>2D_parallel_julia.c</code>)
  that does not allocate memory or compute anything for now, but
  that merely has each process print out its rank, it's 2-D rank, and the pixel row
  and column ranges for which it is responsible.
</p>

<p class="ui">
  Run your program on this simple simulated 1024-node cluster
  (download <a href="simple_cluster.xml">simple_cluster.xml</a> and
  <a href="simple_cluster_hostfile.txt">simple_cluster_hostfile.txt</a>). These
  are the same files are for Activity #1.
</p>

<br />
<div class="ui divider"></div>


<p class="ui">
  Below are a few sample executions of the program:
</p>

<div class="ui accordion  fluid">

  <div class="title">
    <i class="dropdown icon"></i>
    See a sample execution with 9 processes for n=30 ...
  </div>

  <div class="  styled content">

    <div class="ui container raised segment">

<figure class="highlight"><pre><code class="language-text" data-lang="text">% smpicc -O3 2D_parallel_julia.c -o 2D_parallel_julia
% smpirun -np 9 -hostfile ./simple_cluster_hostfile.txt -platform ./simple_cluster.xml ./1D_parallel_julia 30
[Process rank 0]: my 2-D rank is (0, 0), my tile is [0:9, 0:19]
[Process rank 1]: my 2-D rank is (0, 1), my tile is [0:9, 20:39]
[Process rank 2]: my 2-D rank is (0, 2), my tile is [0:9, 40:59]
[Process rank 3]: my 2-D rank is (1, 0), my tile is [10:19, 0:19]
[Process rank 4]: my 2-D rank is (1, 1), my tile is [10:19, 20:39]
[Process rank 5]: my 2-D rank is (1, 2), my tile is [10:19, 40:59]
[Process rank 6]: my 2-D rank is (2, 0), my tile is [20:29, 0:19]
[Process rank 7]: my 2-D rank is (2, 1), my tile is [20:29, 20:39]
[Process rank 8]: my 2-D rank is (2, 2), my tile is [20:29, 40:59]</code></pre></figure>

    </div>
  </div>

  <div class=" title">
    <i class="dropdown icon"></i>
    See a sample execution with 16 processes for n=200 ...
  </div>

  <div class=" content">
    <div class="ui container segment raised">

<figure class="highlight"><pre><code class="language-text" data-lang="text">% smpicc -O3 2D_parallel_julia.c -o 2D_parallel_julia
% smpirun -np 16 -hostfile ./simple_cluster_hostfile.txt -platform ./simple_cluster.xml ./2D_parallel_julia 200
[Process rank 0]: my 2-D rank is (0, 0), my tile is [0:49, 0:99]
[Process rank 1]: my 2-D rank is (0, 1), my tile is [0:49, 100:199]
[Process rank 2]: my 2-D rank is (0, 2), my tile is [0:49, 200:299]
[Process rank 3]: my 2-D rank is (0, 3), my tile is [0:49, 300:399]
[Process rank 4]: my 2-D rank is (1, 0), my tile is [50:99, 0:99]
[Process rank 5]: my 2-D rank is (1, 1), my tile is [50:99, 100:199]
[Process rank 6]: my 2-D rank is (1, 2), my tile is [50:99, 200:299]
[Process rank 7]: my 2-D rank is (1, 3), my tile is [50:99, 300:399]
[Process rank 8]: my 2-D rank is (2, 0), my tile is [100:149, 0:99]
[Process rank 9]: my 2-D rank is (2, 1), my tile is [100:149, 100:199]
[Process rank 10]: my 2-D rank is (2, 2), my tile is [100:149, 200:299]
[Process rank 11]: my 2-D rank is (2, 3), my tile is [100:149, 300:399]
[Process rank 12]: my 2-D rank is (3, 0), my tile is [150:199, 0:99]
[Process rank 13]: my 2-D rank is (3, 1), my tile is [150:199, 100:199]
[Process rank 14]: my 2-D rank is (3, 2), my tile is [150:199, 200:299]
[Process rank 15]: my 2-D rank is (3, 3), my tile is [150:199, 300:399]</code></pre></figure>

    </div>
  </div>

</div>




</div>



<div class="ui bottom attached tab segment" data-tab="2D_compute_julia">

  <p class="ui">
  Augment your program so that each process allocates space to store the pixels it needs to compute, and
  then computes them. As in the previous activity, the main difficulty here is
  keeping local vs. global indexing straight. It is a bit more complex
  than for Activity #2 due to the use of a 2-D data distribution.
</p>

<p class="ui">
  Have each process apply a <i>tint</i> to the pixels it handles, by passing
  value <code>rank<sup>2</sup></code> (i.e., the square of the rank) as the 5th argument to
  function <code>compute_julia_pixel()</code> (instead of passing the default
  1.0 value).
</p>




</div>



<div class="ui bottom attached tab segment" data-tab="2D_save_to_file">

  <p class="ui">
  Augment your program so that the Julia set is saved to a bmp file.
  The difference with Activity #2 is that now each process holds a tile, and
  yet the file must contain the pixels in row major order. So each process
  will have to append many times to the file, writing one piece of a row at a time.
  As a result, more complex coordination is required compared to
  Activity #2.
</p>


<div class="ui accordion fluid">
  <div class=" title">
    <i class="dropdown icon"></i>
    See a visual example/explanation ...
  </div>
  <div class="content">
    <div class="ui message ">
      <div class="ui grid">

        <div class="ui row">
          <p style="text-align:center;" class="ui">
          <img align="center" src="./2D_file_writing_pattern_figure.jpg" width="300px" />
          </p>
        </div>
        <div class="ui row">
      The figure above shows an example with 9 processes (2-D rank coordinates are shown
      in red), where each process holds a 4x8 tile (4 row segments).  The numbers on
      each segment indicate the sequence in which the pixels must be written to the
      file. In this example, there are 36 row segments. First process (0,0)
      writes its first segment, then process (0,1) writes its first segment, etc.  
      For instance, at step 20, process (1,1) writes its third segment. You must implement
          the "go ahead!" messaging scheme so that the processes write to the file in
          the correct order.
        </div>
    </div>
    </div>
  </div>
</div>

<div class="ui divider"></div>

Using a tint of <code>1.0</code> at each process, this program should produce the
same images as that in Activity #2 (which can be useful for debugging). When using
<code>rank<sup>2</sup></code>, one sees a checkered pattern. Here is a sample
image generated
with 9 processors for n=300:
<br />
<br />

<p style="text-align:center;" class="ui">
  <img align="center" width="400" src="./julia_small_checkered.jpg" />
</p>



</div>
</div>

<div class="ui tab segment" data-tab="fifth">
  <div class="ui container raised segment fluid">

  <h3 class="ui header">What have we learned?</h3>

  <p class="ui">
    Congratulations for making it this far. At this point you have learned how
    to design a distributed-memory application as an SMPD program using SMPI, have been
    exposed to both 1-D and 2-D data distributions, and have
    learned how to use communication to orchestrate the executions of MPI
    processes.  You may also have learned about memory layouts of 2-D arrays.
  </p>

  <p class="ui">
    Our Julia set computation is a "toy application". Admittedly, our use of
    a 2-D data distribution made the application more complicated to write without
    any clear benefit. We will see other examples for which 2-D data distributions
    provide significant performance advantages.  Also, we handled all file I/O
    "by hand". In practice, MPI provides a set of abstractions and functions to perform parallel
    I/O, called MPI IO, that could be used to achieve better performance on a real
    systems with high-performance parallel file systems.
  </p>



</div>

<div class="ui container raised segment fluid">

  <h3 class="ui header">What was difficult?</h3>

  <p class="ui">
    In a README file write a brief "essay" explaining what you found
    surprising/challenging, and what solutions you used to solve
    your difficulties. Are you happy with your implementations? Do you
    see room for improvement?
  </p>


</div>


<div class="ui container raised segment fluid">

<div class="ui horizontal divider">
  The End
</div>

</div>
</div>



  <br>

</div>
	</div>



</body>
</html>
