<p class="ui">
  Implement an MPI program called <code>matmul_init</code> (<code>matmul_init.c</code>) that takes a
  single command-line argument, <i>N</i>, which is a strictly positive integer. <i>N</i> is the
  dimension of the square matrices that we multiply. Your program should check that the number of processes
  is a perfect square, and that its square root divides N (printing an error message and exiting if this is
  not the case).
</p>

<p class="ui">
  The objective of the program is for each process to allocate and initialize its block of each matrix.
  We multiply particular matrices, defined by:
  </p>
<p class="ui">
  <i>A<sub>i,j</sub> = i</i> &nbsp; and  &nbsp; <i>B<sub>i,j</sub> = i + j</i>.
</p>



<p class="ui">
  <b>The above is with global indices, which go from 0 to N-1.</b>
</p>


<p class="ui">
Given the above definitions of A and B, there is a simple analytical solution
  for C. There is thus a closed-form expression for the sum of the
  elements of C: <b><i>N<sup>3</sup> (N - 1)<sup>2</sup> / 2</i></b>.
  You will use this formula to check the validity of your matrix
  multiplication implementation in Activity #2.
</p>

<p class="ui">
  Have each process allocate its blocks of A, B, and C, initialize its blocks
  of A and B to the appropriate values, and then print out the content of
  these blocks.  Each process should print its MPI rank (the "linear rank")
  as well as its
  2-D rank, which is easy to determine based on the linear rank. 
  </p>

<p class="ui">
  For instance, here is an excerpt from the output (that generated by the process of rank 2)
  for p=4 and N=8, using
  <a href="./cluster_crossbar_64.xml">cluster_crossbar_64.xml</a> as a platform file
  and <a href="./hostfile_64.txt">hostfile_64.txt</a> as a hostfile (since this module is
  about correctness, you can use pretty much any such valid files).
</p>

<div class="ui container raised segment">
  {% highlight text %}
% smpirun -np 4 \
          -platform cluster_crossbar_64.xml \
          -hostfile hostfile_64.txt \
          ./matmul_init 8
[...]
Process rank 2 (coordinates: 1,0), block of A:
4.0 4.0 4.0 4.0
5.0 5.0 5.0 5.0
6.0 6.0 6.0 6.0
7.0 7.0 7.0 7.0
Process rank 2 (coordinates: 1,0), block of B:
4.0 5.0 6.0 7.0
5.0 6.0 7.0 8.0
6.0 7.0 8.0 9.0
7.0 8.0 9.0 10.0
[...]
{% endhighlight %}
</div>



<p class="ui">
  Note that due to the convenience of simulation,
  the output from one process will never be interleaved with the output of
  another process. If you run this code "for real" with MPI, instead of SMPI,
  output will be interleaved and additional synchronization will be needed
  to make the output look nice.
  The order in which the processes output their blocks is inconsequential.
  You may want to use a barrier synchronization
  to first see all blocks of A and then all blocks of B though.

  </p>

<p class="ui">
  Obviously, we wonâ€™t run this program for large N.
  The goal is simply to make sure that matrix blocks are initialized
  correctly on all processes.

</p>




