<p class="ui">
  Implement a program called <code>lu</code> (<code>lu.c</code>), that implements the
  Gaussian elimination (without pivoting) algorithm.   You may have covered this algorithm in a course,
  and it is of course well-document in various texts.  Regardless, a sequential implementation,
  <code><a href="./sequential_lu.c">sequential_lu.c</a></code>, is provided. So you can use it as a starting point
  in a "let's parallelize an existing sequential implementation" scenario.
</p>


<p class="ui">
  To make it easy to test your implementation, we compute the LU factorization of a particular
  matrix defined as follows:

<p style="text-align:center;" class="ui">
  <img align="center" src="./lu_matrix.jpg" width="180">
</p>
(note that the indices start at 0).
</p>

<p class="ui">
  The matrix, once the Gaussian Elimination is complete, will have all 1â€™s in its lower triangular portion, 
  and i<sup>2</sup> values on its diagonal and in its upper triangular portion.
  Run <code>lu_sequential.c</code> with a small value of N to see this structure. Your code should check
  that these are the values computed by your implementation (each process can do its own check).
</p>

<p class="ui">
  You can use any XML platform file and accompanying hostfile to run your MPI program,
  since this module is solely about correctness and not performance. For instance,
  you can use
  <a href="./cluster_crossbar_64.xml">cluster_crossbar_64.xml</a> as a platform file
  and <a href="./hostfile_64.txt">hostfile_64.txt</a> as a hostfile.
</p>

<p>For debugging purposes, remember that it's a good idea to insert calls to <code>MPI_Barrier</code>
  so that debugging output from the program can be structured step-by-step.
</p>
