<p class="ui">
  Report the (simulated) wall-clock time of
  default_bcast,
  asynchronous_pipelined_ring_bcast, and
  asynchronous_pipelined_bintree_bcast, on
  a 50-processor ring platform and a 50-processor binary tree platform.
  For asynchronous_pipelined_ring_bcast and
  asynchronous_pipelined_bintree_bcast use the "best chunksize" you determined
  in Activity #3 for the 50-processor ring platform.
  </p>

<p class="ui">
  You are provided with a Python script
  (<a href="./generate_xml_bintree_and_hostfile.py">generate_xml_bintree_and_hostfile.py</a>)
  that generates the XML file (and hostfile) for the binary tree platform. As for
  the <a href="./generate_xml_bintree_and_hostfile.py">generate_xml_bintree_and_hostfile.py</a> script,
  the number of processors is passed as a command-line
  argument. Just in case,
  here are the files generated using this script for 50 processors: <a href="bintree_50.xml">bintree_50.xml</a> and
  <a href="hostfile_50.txt">hostfile_50.txt</a>.
</p>

<p class="ui">
  Answer the following questions:
<div class="ui list bulleted">
  <div class="ui item">
    On the 50-processor ring platform, how does asynchronous_pipelined_bintree_bcast compare
    to asynchronous_pipelined_ring_bcast?  Is it unexpected?
    </div>
  <div class="ui item">
    On the 50-processor binary tree platform, how do the three implementations compare?
    Does it seem worth it to implement your own binary tree broadcast on a binary tree physical
    platform?
  </div>

</div>
</p>


